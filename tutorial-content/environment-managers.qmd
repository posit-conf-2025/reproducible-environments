---
title: Environment Management
from: markdown+emoji
---

```{r, setup, include = FALSE}
library(dplyr)
library(renv)
```

# Reproducible Analytics

Setting out to build a robust _statistical computing environment_ (SCE), we
need to tackle reproducibility.

Reprodubility is **always** a tradeoff. We want to land somewhere actionable,
that is within our tolerance for error.

| **What we manage**     | **How actionable it is** |
| ---------------------- | ------------------------ |
| Our scripts            | piece of :cake:          |
| R package dependencies | :thinking:               |
| R version              | :thinking:               |
| System libraries       | :confounded:             |
| OS                     | :confounded:             |
| System architecture    | :weary:                  |
| Fluke gamma radiation  | :dizzy_face:             |

# Tools

We'll assume we know how to reproducibly hand our code off. The next step
is managing our R version and dependencies. There are a ton of great tools for
this!

* `renv`: an R-based tool for reproducibly installing local R package libraries
  and keeping project environments isolated.
* `rix` leverages the `nix` package management ecosystem to distribute packages
  and build fully reproducible installs.
* `r2u` leverages the Ubuntu package ecosystem managed through `apt` to
  distribute R packages.
* `packrat`: ("soft-deprecated") Predecessor to `renv`.
* `pak`: a fresh approach to R package installation. Allows for highly parallel package installations, auto-detects and installs system dependencies.
* `rv`: a rust-based tool to install R packages in a reproducible, fast, and declarative way, similarly to `uv` in the python ecosystem. 

Let's see a few examples in action.

## [`renv`](https://rstudio.github.io/renv/index.html)

Represents the set of packages used in a project in an explicit `renv.lock`
file, including the sources of the package and reproducibility metadata like
md5 checksums. Also manages your local library to ensure that your global
package library doesn't leak into your project environment.

In fact, we used `renv` to make this presentation reproducible!

### Quick Demo

Just for demonstration, we'll swap over to a temporary directory to set up our
`renv`.

```{r, warning = FALSE}
renv_proj_dir <- file.path(tempdir(), "renv-demo")
dir.create(renv_proj_dir)
setwd(renv_proj_dir)
```

```{r, change-wd-to-renv, include = FALSE}
# just for knitting this document, tell knitr we'll be working in a
# different directory
knitr::opts_knit$set(root.dir = renv_proj_dir)
```

We'll initialize a project

```{r}
renv::init()
```

And add some analytic code to our project

```{r}
"
library(dplyr)

starwars |>
  group_by(eye_color) |>
  summarize(count = n()) |>
  arrange(-count) |>
  head(5)
" |> 
  write(file = file.path(renv_proj_dir, "analysis.R"))

# add our new dependencies
renv::install("dplyr")

# snapshot our new project environment
renv::snapshot()
```

Let's take a look at what `renv.lock` grabbed

```{r}
readLines(file.path(renv_proj_dir, "renv.lock")) |>
  head(50) |>
  paste(collapse = "\n") |>
  cat()
```

## [`rix`](https://github.com/ropensci/rix/)

::: {.callout-note}
## `rix` Maturity

`rix` uses the `nix` package manager, which can be used for all kinds of system
dependencies. It is more comprehensive in its reproducibility, but the R package is less
mature (in terms of years, users) ecosystem. The NIX ecosystem however exists since at least 2006.
:::

::: {.callout-warning}
## Private Packages

`nix` expects fully reproducible declarative builds, which are in conflict 
with _private_ repositories. If you need to use private packages, the best
option is to vendor your own code.
[ropensci/rix#452](https://github.com/ropensci/rix/issues/452#issuecomment-2725267329)
:::

If those haven't deterred you and you'd like to be on the leading edge of
full system reproducibility, then `rix` offers the perfect solution.

### Example Project Bootstrapping

```{r, eval = FALSE}
library(rix)

path_default_nix <- "."

rix(
  r_ver = "4.3.3",                # Change to whatever R version you need
  r_pkgs = c("dplyr", "ggplot2"),  # Change to whatever packages you need
  system_pkgs = NULL,
  git_pkgs = NULL,
  ide = "code",
  project_path = path_default_nix,
  overwrite = TRUE,
  print = TRUE
)
```

## [`r2u`](https://eddelbuettel.github.io/r2u/)

`r2u` _supplements_ a full reproducibility solution. It allows for **fast**
installation of package binaries on a Debian-based system using a Debian
software repository and `apt`.

`r2u` could be used in conjunction with a container built on top of a
Debian-based base image to build a container-based R environment.

## [`slushy`](https://github.com/GSK-Biostatistics/slushy)

`slushy` provides a wrapper around `renv` to make it a bit more accessible for
evolving analytic environments. Designed to be _slightly less frozen_, slushy
provides helpers for updating an `renv` after it's created.

## [`pak`](https://pak.r-lib.org/)

A fresh approach to package installation. Enables full reproducibility like renv. More a tool for data science or system admins. Speeds up package installations by parallelizing the install process all the way. Very helpful with detecting operating system dependencies (can be automatically be installed when run with admin privileges). 

### Quick demo

The below will install tidyverse including all R dependencies, fully in parallel. 

```{r, eval = FALSE}
# Let's install tidyverse
pak::pak("tidyverse")
```

::: {.callout-note}
## `pak` parallelism

With the release of R 4.5.0, package installation in R via `install.packages()` has been sped up by downloading packages in parallel. `pak` will not only download packages in parallel, it will also compile, build and install them in parallel, leading to further efficiency gains. 
:::

### System dependencies 

Very often R package installation fails due to missing system dependencies. In such cases pak can help any user to figure out which OS packages need to be installed by running 

```{r, eval = FALSE} 
pak::pkg_sysreqs("sf")
```

which produce an output similar to (example is for a system running on Ubunut 20.04 (Focal)) 
```
── Install scripts ────────────────────────────────────────────────────────────────────────────────────── Ubuntu 20.04 ──
apt-get -y update
apt-get -y install cmake libssl-dev libgdal-dev gdal-bin libgeos-dev libproj-dev libsqlite3-dev libudunits2-dev

── Packages and their system dependencies ───────────────────────────────────────────────────────────────────────────────
s2    – cmake, libssl-dev
sf    – gdal-bin, libgdal-dev, libgeos-dev, libproj-dev, libsqlite3-dev
units – libudunits2-dev
```

::: {.callout-note}
## Good to know

If `pak::pak()` is run with admin privileges, not only all the R packages are being installed but also any missing system dependency will be installed. 
:::

### Reproducibility

Reproducibility can be achieved via lock files, similarly to renv. 

```{r, eval = FALSE}
# Let's create a lockfile for reproducibility
pak::lockfile_create()

# We can use the created pkg.lock file any time on another system to run 
pak::lockfile_install()
```

## [`rv`](https://a2-ai.github.io/rv-docs/)

`rv` is a fairly new tool that lives outside of R and needs to be called from the command line. It can be compared with [`uv`](https://docs.astral.sh/uv/) in the python ecosystem. There is good information in the [Getting Started Guide](https://a2-ai.github.io/rv-docs/intro/getting-started/).
